#!/usr/bin/env python3
"""
Thomas-Wigner Precession Experiment for CGM

This module implements the Thomas-Wigner rotation experiment that provides
a clean, falsifiable, dimensionless result tying CGM gyration to physical effects.

Claim: In the Einstein-Ungar model, the rotation (monodromy) generated by
composing two non-collinear boosts equals the gyro-triangle defect, up to
numerical error.

For small velocities ||u||, ||v|| << c:
    θ_TW ≈ ||u×v||/(2c²)  (dimensionless angle)

This is a clean, falsifiable statement involving only c and gyration implementation.
"""

import numpy as np
from typing import Dict, Any, List
import sys
import os

from .functions.gyrovector_ops import GyroVectorSpace


def tw_angle_from_gyration(gs: GyroVectorSpace, u: np.ndarray, v: np.ndarray) -> float:
    """
    Extract Thomas-Wigner rotation angle from gyr[u,v], using your gyration()
    which returns an SO(3)-like matrix. Works best for small |u|,|v|.

    Args:
        gs: GyroVectorSpace instance
        u, v: Velocity vectors

    Returns:
        Rotation angle in radians
    """
    R = gs.gyration(u, v)  # 3x3 rotation approx
    tr = float(np.trace(R))
    tr = np.clip(tr, -1.0, 3.0)
    angle = np.arccos((tr - 1.0) / 2.0)  # principal rotation angle
    return float(abs(angle))


def tw_small_angle_theory(u: np.ndarray, v: np.ndarray, c: float) -> float:
    """
    θ ≈ |u×v|/(2 c²) for small velocities.

    Args:
        u, v: Velocity vectors
        c: Speed of light

    Returns:
        Theoretical small-angle prediction
    """
    return float(np.linalg.norm(np.cross(u, v)) / (2.0 * c**2))


def batch_check(
    n: int = 200, beta_max: float = 0.1, seed: int = 0, c: float = 1.0
) -> Dict[str, Any]:
    """
    Random small-velocity checks. Returns statistics of residuals
    between numerical gyration angle and the small-angle theory.

    Args:
        n: Number of random tests
        beta_max: Maximum velocity as fraction of c
        seed: Random seed for reproducibility
        c: Speed of light

    Returns:
        Dictionary with statistics of residuals
    """
    rng = np.random.default_rng(seed)
    gs = GyroVectorSpace(c=c)
    residuals_list: List[float] = []

    for _ in range(n):
        # Generate random unit vectors
        u = rng.normal(0, 1, 3)
        u = u / np.linalg.norm(u) * (beta_max * c * rng.random())

        v = rng.normal(0, 1, 3)
        v = v / np.linalg.norm(v) * (beta_max * c * rng.random())

        # Compute numerical and theoretical angles
        theta_num = tw_angle_from_gyration(gs, u, v)
        theta_th = tw_small_angle_theory(u, v, c)

        residuals_list.append(theta_num - theta_th)

    residuals = np.array(residuals_list)

    return {
        "mean_residual": float(np.mean(residuals)),
        "std_residual": float(np.std(residuals)),
        "max_abs_residual": float(np.max(np.abs(residuals))),
        "n": n,
        "beta_max": beta_max,
        "c": c,
    }


def slope_check(
    n: int = 400,
    beta_max_list: tuple = (0.02, 0.03, 0.05, 0.08, 0.10),
    seed: int = 0,
    c: float = 1.0,
) -> List[Dict[str, Any]]:
    """
    Regress theta_num vs |u×v|/(2c²) for several beta_max.
    Expect slope ~ 1 and residuals ~ O(beta_max^3).
    """
    rng = np.random.default_rng(seed)
    gs = GyroVectorSpace(c=c)
    rows = []

    for beta_max in beta_max_list:
        X_list: List[float] = []
        Y_list: List[float] = []
        for _ in range(n):
            u = rng.normal(0, 1, 3)
            u = u / np.linalg.norm(u) * (beta_max * c * rng.random())
            v = rng.normal(0, 1, 3)
            v = v / np.linalg.norm(v) * (beta_max * c * rng.random())
            Y_list.append(tw_angle_from_gyration(gs, u, v))
            X_list.append(tw_small_angle_theory(u, v, c))

        X = np.array(X_list)
        Y = np.array(Y_list)
        # slope with intercept forced to 0 (theory is homogeneous)
        slope = float(np.dot(X, Y) / np.dot(X, X))
        resid = Y - slope * X

        rows.append(
            {
                "beta_max": beta_max,
                "slope": slope,
                "mean_abs_resid": float(np.mean(np.abs(resid))),
                "max_abs_resid": float(np.max(np.abs(resid))),
            }
        )

    return rows


def test_tw_precession_small_angle() -> Dict[str, Any]:
    """
    Test Thomas-Wigner precession for small angles.

    Returns:
        Test results
    """
    print("Testing Thomas-Wigner Precession (Small Angle)")
    print("=" * 50)

    stats = batch_check(n=500, beta_max=0.05, seed=123, c=1.0)

    print(f"Number of tests: {stats['n']}")
    print(f"Max velocity: {stats['beta_max']:.3f}c")
    print(f"Mean residual: {stats['mean_residual']:.2e}")
    print(f"Std residual: {stats['std_residual']:.2e}")
    print(f"Max abs residual: {stats['max_abs_residual']:.2e}")

    # Expect tiny errors in the linear regime
    validation_passed = stats["max_abs_residual"] < 5e-6

    print(f"Validation: {'PASS' if validation_passed else 'FAIL'}")

    return {**stats, "validation_passed": validation_passed}


def main():
    """Run the Thomas-Wigner precession experiment."""
    print("THOMAS-WIGNER PRECESSION EXPERIMENT")
    print("=" * 50)
    print("Testing gyration ↔ hyperbolic triangle defect equivalence")
    print()

    results = test_tw_precession_small_angle()

    if results["validation_passed"]:
        print("\n🎯 SUCCESS: Thomas-Wigner rotation ≈ hyperbolic defect")
        print("   This validates the core CGM gyro-geometry!")
    else:
        print("\n⚠️  NEEDS REFINEMENT: Numerical precision issues detected")

    # Add slope check for scaling validation
    print("\nTW scaling (theta vs |u×v|/2c²):")
    rows = slope_check()
    for r in rows:
        print(
            f"  β≤{r['beta_max']:.2f}: slope={r['slope']:.6f} max|res|={r['max_abs_resid']:.2e}"
        )
    # Gate: slope ~ 1 within a few e-4 at β≤0.05, residuals shrinking ~ β^3

    return results


if __name__ == "__main__":
    main()
